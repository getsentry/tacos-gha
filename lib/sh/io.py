from __future__ import annotations

import contextlib
from os import getenv
from typing import ContextManager
from typing import Iterable
from typing import TypeVar

from lib import ansi

from .constant import STDERR as STDERR
from .constant import STDIN as STDIN
from .constant import STDOUT as STDOUT
from .types import FD as FD
from .types import Command
from .types import Generator

PS4 = f"+ {ansi.TEAL}${ansi.RESET} "


# 1 - info
# 2 - debug
# 3 - trace
# note: empty-string vars should be treated as unset
DEBUG: int = int(getenv("DEBUG") or "1")

T = TypeVar("T")
Uniq = set[tuple[object, ...]]
UNIQ: Uniq | None = None


def info(*msg: object) -> None:
    """Show the user a message."""

    from sys import stderr

    if UNIQ is not None and msg in UNIQ:
        return  # duplicate message in a `uniq` context

    print(*msg, file=stderr, flush=True)

    if UNIQ is not None:
        UNIQ.add(msg)


def banner(*msg: object) -> None:
    """Show a colorized, high-visibility message."""
    info(ansi.GREEN, "=" * 8, *msg, "=" * 8, ansi.RESET)


def _stringify(o: object) -> str:
    if isinstance(o, bytes):
        return o.decode("US-ASCII")  # other bytes are ambiguous
    else:
        return str(o)


def quote(cmd: Command) -> str:
    """Escape a command to copy-pasteable shell form.

    >>> print(quote(("ls", "1 2", 3, "4")))
    ls '1 2' 3 4
    """
    import shlex

    return " ".join(shlex.quote(_stringify(arg)) for arg in cmd)


def xtrace(cmd: Command, *, level: int = 1) -> None:
    """Simulate bash's xtrace: show a command with copy-pasteable escaping.

    Output is suppressed when `sh.DEBUG` (default 1) is less than `level`.
    """
    debug("".join((PS4, quote(cmd))), level=level)


def comment(*msg: object, level: int = 1) -> None:
    """Print a bash-style comment to the log, with de-emphasized color."""
    msg = (ansi.GREY + "#", *msg, ansi.RESET)
    debugN(msg, level)


def debugN(msg: Iterable[object], level: int) -> None:
    if DEBUG >= level:
        info(*msg)


def debug(*msg: object, level: int = 1) -> None:
    debugN(msg, level)


def debug1(*msg: object) -> None:
    debugN(msg, 1)


def debug2(*msg: object) -> None:
    debugN(msg, 2)


def debug3(*msg: object) -> None:
    debugN(msg, 3)


@contextlib.contextmanager
def verbosity(newvalue: int) -> Generator[int]:
    """Temporarily disable the noise generated by xtrace."""
    global DEBUG
    orig, DEBUG = DEBUG, newvalue
    try:
        yield orig
    finally:
        DEBUG = orig


@contextlib.contextmanager
def noop_context(x: T) -> Generator[T]:
    yield x


def quiet() -> ContextManager[int]:
    if getenv("DEBUG") is None:
        return verbosity(0)
    else:
        return noop_context(DEBUG)


def loud() -> ContextManager[int]:
    if getenv("DEBUG") is None:
        return verbosity(2)
    else:
        return noop_context(DEBUG)


@contextlib.contextmanager
def uniq() -> Generator[Uniq]:
    """Only show unique log messages."""
    global UNIQ
    newvalue: Uniq = set()
    orig, UNIQ = UNIQ, newvalue
    try:
        yield newvalue
    finally:
        UNIQ = orig


@contextlib.contextmanager
def redirect(from_: FD, to: FD) -> Generator[FD]:
    """Enable translating shell syntax `2>&1` to `redirect(2, 1)`."""
    from os import close
    from os import dup
    from os import dup2

    tmp = dup(from_)

    debug2(f"{PS4}exec {tmp}>&{from_} {from_}>&{to}")
    dup2(to, from_)
    try:
        yield tmp
    finally:
        dup2(tmp, from_)
        close(tmp)
        debug2(f"{PS4}exec {from_}>&{tmp}")
