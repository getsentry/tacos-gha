from __future__ import annotations

import contextlib
from os import getenv
from typing import ContextManager

from lib import ansi

from .types import Command
from .types import Generator

PS4 = f"+ {ansi.TEAL}${ansi.RESET} "


# TODO: use logging module? probs not...
# 0 - info only
# 1 - debug
# 2+ - trace
DEBUG: int = int(getenv("DEBUG", "1"))

Uniq = set[tuple[object, ...]]
UNIQ: Uniq | None = None


def info(*msg: object) -> None:
    """Show the user a message."""

    from sys import stderr

    if UNIQ is not None and msg in UNIQ:
        return  # duplicate message in a `uniq` context

    print(*msg, file=stderr, flush=True)

    if UNIQ is not None:
        UNIQ.add(msg)


def banner(*msg: object) -> None:
    """Show a colorized, high-visibility message."""
    info(ansi.GREEN, "=" * 8, *msg, "=" * 8, ansi.RESET)


def quote(cmd: Command) -> str:
    """Escape a command to copy-pasteable shell form.

    >>> print(quote(("ls", "1 2", 3, "4")))
    ls '1 2' 3 4
    """
    import shlex

    return " ".join(shlex.quote(str(arg)) for arg in cmd)


def xtrace(cmd: Command) -> None:
    """Simulate bash's xtrace: show a command with copy-pasteable escaping.

    Output is suppressed when `sh.DEBUG` is False.
    """
    debug("".join((PS4, quote(cmd))))


def debug(msg: object) -> None:
    if DEBUG:
        info(msg)


@contextlib.contextmanager
def verbosity(newvalue: int) -> Generator[int]:
    """Temporarily disable the noise generated by xtrace."""
    global DEBUG
    orig, DEBUG = DEBUG, newvalue
    yield orig
    DEBUG = orig


def quiet() -> ContextManager[int]:
    return verbosity(0)


def loud() -> ContextManager[int]:
    return verbosity(2)


@contextlib.contextmanager
def uniq() -> Generator[Uniq]:
    """Only show unique log messages."""
    global UNIQ
    newvalue: Uniq = set()
    orig, UNIQ = UNIQ, newvalue
    yield newvalue
    UNIQ = orig
